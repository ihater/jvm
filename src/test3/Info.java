package test3;
/**
 * Sun Classic VM :
 * 		世界上第一款商用的Java虚拟机
 * 		只能使用纯解释器的方式来执行Java代码.
 * Exact VM：
 * 		Exact Memory Management 准确试内存管理（虚拟机可以准确的知道某个位置上的数据是什么类型的）
 * 								知道是什么类型的数据，就可以知道这个数据会不会再被使用。就可以决定会不会回收
 * 		编译器和解释器混合工作以及即时编译器
 * 		只在Solaris平台发布，命短（只在JDK1.2上有）
 * HotSpot VM：
 * 		优势：热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以方法为单位进行编译。
			  如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作
			  通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，
			  即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。
 *
 * KVM：
 * 		嵌入式用的虚拟机产品，简答轻量，高度可移植
 * 		在手机上运行	
 * 
 * Dalvik：	  
 * 		
 */
public class Info {
/**
 *					运行时数据区
|---------------------------------------------------------------|
|		线程共享区			|			线程独占区				|
|	-------------------		|									|
|	| 				  |		|	----------		-------------	|
|	| 	方法区（常量池）|		|	| 虚拟机栈  |		| 本地方法栈  | 	|	 
|	|-----------------|		|	 ----------		-------------	|
|	|  				  |		|									|
|	|	JAVA堆      	  |		|		---------------------		|
|	| 存储对象实例	  |		|		|	   程序计数器	     |		|
|	-------------------		|		----------------------		|
| 							|									|
|---------------------------------------------------------------|
			||								||
		    执行引擎	--------------->     本地库接口	-------> 本地方法区
 *
		 * 方法区：存储运行时 常量池，已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据
		 * JAVA堆：存储对象实例
		 * 
		 * 虚拟机栈：存放方法运行所需要的数据，成为栈帧（什么是栈帧，以后讲）
		 * 本地方法栈 ：为JVM所谓用到的Nativa脚本地方法服务
		 * 程序计数器：记录当前线程执行到的字节码的行号
 * 
 * =========================================================================================================
 * 
 * 程序计数器：
 * 		是一块较小的内存空间，他可以看做是当前线程所执行的字节码的行号指示器
 * 		程序计数器所处于的行号指示器
 * 		如果程序执行的Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址
 * 		如果正在执行的是native方法，这个计数器的值为undefined。
 * 		此区域是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError情况的区域
 * 		因为，开发者完全不需要去操作这块区域。完全由JVM内部自己维护，没有内存溢出的情况
 * 
 * Java虚拟机栈：
 * 		描述的是Java方法执行的动态内存模型（方法执行进栈，引用到别的方法，也进栈。执行完出战，先进后出）
 * 		栈帧：
 * 			每个方法执行，都会创建一个栈帧，伴随着方法从 创建到执行完成。
 * 			用于存储局部变量表、操作数栈、动态链接、方法出口等。
 * 			在栈空间满的情况下，继续向栈存栈帧，就会爆 StackOverFlow 的错，比如没有收敛的循环。看demo。
 * 		局部变量表：
 * 			存放编译期可知的各种基本数据类型，引用类型，returnAddress类型
 * 			局部 变量表所需要的空间，在编译期，就完成了内存的分配，在方法运行的期间，是不会改变大小的（24/06分）
 * 			当进入到一个方法的时候，这个方法会变成栈帧，这个帧中需要分配多大空间，就已经固定了，不会改变
 * 			？？为什么大小不会改变？？比如有个 User对象有name属性，在运行期间，会给name赋值。
 * 			但是，在运行期间，这个name属性可改变。所以长度是不固定的，那为什么长度不会变化呢？？
 * 			！！所以，其实我们在局部变量表中，存放的只是 User对象的引用，引用的长度是不变的！！！
 * 			对象的创建，会创建到  堆内存中，而栈中的局部变量表，只是有一份这个对象的引用。
 * 		大小：
 */
}
