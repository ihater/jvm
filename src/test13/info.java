package test13;
/**
 * 因为Java有各种需求常常见，根据不同的业务需求特点
 * 产生了不同的垃圾收集器，比如服务器的，移动端的，嵌入式的
 * 
 *	垃圾收集器：
 *		Serial：
 *			最基本，历史最久，单线程的垃圾收集器
 *				就是，当要执行垃圾收集的时候，其他线程全都要停止
 *				执行完垃圾收集，其他线程才能继续执行
 *				为什么要这么设计？？？就好像扫地和扔垃圾，如果扫地的时候，还在扔垃圾，就永远 扫不完
 *			多用在桌面应用，对于分配内存小，单线程效率高，基本无感应
 *
 *		ParNew：
 *			多线程的垃圾收集器
 *		
 *		CMS：	
 *			微软开发超级牛逼的收集器，专门负责清理老年代内存
 *			真正多线程，真正做到可以边扔垃圾边清理内存.
 *		
 *		Parallel Scavenger 收集器：
 *			复制算法（针对新生代内存的收集器）
 *			多线程的处理器。
 *
 *		CMS收集器：
 *			标记清除算法，并发手机，低停顿，收集老年代的内存
 *			占用大量CPU资源，无法处理浮动垃圾，空间碎片需要处理
 *			
 *		G1收集器
 *			最牛叉的，没有之一
 *			服务端使用的收集器，擅长利用多核环境，做并行并发。
 *			分代收集。优化的分代收集，因为有一张表来记录划分出来的每个内存区块的状态
 *			并评估哪个区块是最值得回收的
 *			空间整合。避免产生大量碎片。
 *			可预测的停顿。
 *			
 *				
 */
public class info {

}
