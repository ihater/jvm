package test21;
/**
 *	加载：
 *		通过一个类的全限定名来获取定义此类的二进制流
 *			从哪里获取二进制流
 *				文件（Class，jar），网络（），计算生成二进制流（proxy类）
 *		将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
 *		在内存中生成一个代表这个类的Class对象，作为这个类的各种数据的访问入口 
 *		
 *	验证：
 *		验证是连接的第一步，这个阶段的目的是为了确保Class文件的字节流中包含的
 *		信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全。
 *		文件格式验证
 *		元数据验证(字节码语意分析，是否有父类，是否继承了final之类的)
 *		字节码验证（最复杂的，分析控制流 ，确定程序的语意识真确的，有意义的）
 *		符号引用验证（校验对象类型是真实存在的，在指定类中的确有该方法和属性）
 *	
 *	准备：
 *		准备阶段正式 为类变量 分配内存并设置变量的初始值
 *		这里的初始值，不是我们赋予的值，而是类型的默认值（默认值，int=0 String=null）。
 *		这些变量使用的内存都在方法区中进行分配
 *		* 如果是 final 常量，就会被赋予指定的值 
 *	
 *	解析：
 *		解析阶段就是虚拟机将常量池中的符号引用替换为直接引用的过程
 *		类或者接口的解析
 *		字段的解析，类方法的解析，接口方法的解析
 *	
 *	初始化：	
 *		初始化就是执行<clinit>() 方法（<>代表泛型）的过程
 *
 *		终于可以根据程序员自己的意愿，初始化一个类的过程。执行类构造器<clinit>()（构造方法）
 *
 *
 *https://blog.csdn.net/u011080472/article/details/51330114
 *Java虚拟机是怎么完成初始化的呢？这要从编译开始讲起。在编
	
	译的时候，编译器会自动收集类中的所有静态变量（类变量）和静态语句块（static｛｝块）中的语句合并产生的，
	编译器收集的顺序是根据语句在java代码中的顺序决定的。
	
	收集完成之后，会编译成java类的 static{} 方法，java虚拟机则会保证一个类的static{} 方法在多线程或者单线程环境中正确的执行
	，并且只执行一次。在执行的过程中，便完成了类变量的初始化。
	
	值得说明的是，如果我们的java类中，没有显式声明static{}块，如果类中有静态变量，编译器会默认给我们生成一个static{}方法
	
	上面我们讲述的是单类的情况，如果出现继承呢？如果有继承的话，父类中的类变量该如何初始化？这点由虚拟机来解决：虚拟机会保证在子类的static{}方法执行之

	前，父类的static{}方法已经执行完毕。由于父类的static{}方法先执行，也就意味着父类的静态变量要优先于子类的静态变量赋值操作。
 */
public class Info {

	static {
		i = 0;
		/**
		 * 为什么System.out.println(i);编译会出错
		 * 
		 */
//		System.out.println(i); 直接这么写，这局会编译出错
	}
	static int  i  =1;
}
