package test12;
/**
 * 	回收的策略
 * ***********************************************************************************************	
 * 	1、	标记-清除算法：
 * 			一般使用可达性分析法标记对象。
 * 			标记完，有一个回收器来回收。
 * 		
 * 		问题：
 * 			效率问题（清除的效率本来就不高）
 * 			空间问题（会产生很多不连续的空间，当要使用一块大内存，空间却不够的时候，还会出发一次垃圾回收）
 *	***********************************************************************************************	
 *	
 *	2、复制算法：
 *
 *
 *		线程共享的区域
 *			堆								为了能实现其他算法的垃圾回收，就把堆内存划分更多区域。
 *				新生代
 *					* Eden  伊甸园（新创建的对象都在伊甸园，垃圾回收器最常关顾的区域）
 *					* Survivor  存活区（没被杀掉的对象，会放在存货去）
 *					* Tenured Gen （老年代，多次没被杀掉的对象，可能使用率很高的对象，垃圾回收器很少关注这块区域）
 *				老年代
 *				
 *			方法区
 *
 *		线程独享的区域
 *			栈
 *			本地方法栈
 *			程序计数器
 *	
 *
 *	就是，不是杀掉不可用对象，可是把可用对象  复制   转移到另外一块内存区域，并排列好，连续
 *	再把伊甸园的空间清空，存活区同理
 *	
 *	但是，这种算法，内存使用率只有一半，因为有一半内存是用来临时存复制堆数据的，只有一半的内存是用在数据计算的
 *
 *	所以，会把内存这么分：
 *			|---------------------------------------------------|
 *			|				10%		|					10%		|
 *			|		Survivor1		|		Survivor2			|		新生代：Eden+Survivor
 *			|		存活区			|		存活区				|		老年代：Tenured Gen
 *			|-----------------------------------|---------------|
 *			|								80%	|				|
 *			|		Eden伊甸园					|	Tenured		|
 *			|									|	Gen			|
 *			|-----------------------------------|---------------|
 *	为什么会有两块 存活区：
 *		复制算法流程：
 *		创建对象的时候，在伊甸园存储。很多对象都再伊甸园创建。垃圾回收的时候，存活的对象，存储在存活区
 *		如果存活对象超过10% ，就占用第二块存活区，存活对象超过 20% ，就占用老年区（内存 担保）		
 *		复制完，就将伊甸园清空。继续新的一轮垃圾回收。
 *
 *		这样，空闲的内存，只有约 10% 
 *	
 **	***********************************************************************************************	
 *	
 */
public class Info {

}
